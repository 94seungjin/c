// 2024년 7월 16일 //
=====================================================
1. review cmd
	gcc -m32 hello.c
	objdump -h a.exe
2. 프로그램(data+algorithm)
======================================================
// 5장. 선택문(if, switch~case) //

가급적 가장 유리한 조건을 앞에 놓는게 유리.

1. if문
	- 0(거짓)이나 0이 아니냐(참)
2. if~else
	- 참 or 거짓
	- cpu pipeline?각각의 역할을 담당하는 sequence.
	- if else문 같은거 만나면 cpu내에서 pipeline이 깨짐.
	- 조건실행(coditional execution) -> 가급적이면 pipeline 안깨려고 함.
	- 사용할 때 가급적이면 안쓰는게 좋음.
3. if ~ else if(여러개 사용가능) ~ else
4. 조건문 사용할 때 주의
	(1) 예제
	if (a>10 ) && ( b++>0 )	// 뒤에 실행이 될 여지가 없기에 조심.
	{
5. algorithm - 여러 종류 다시 살펴보기(stack, array, heap, tree, bstree etc...)
6. switch ~ case
	- 특정 case를 정해놓고 끌어쓰는게 가능.
	- c++에선 enum 함수, define 잘 활용하면 가독성 good.
======================================================
// 6장. 반복문 //

1. while(조건이 참이여야 들어옴)
2. for(3개의 statement)(a;b;c)(a가 초기시작, b 조건맞으면 {안으로, c 행동)
 	(1) 구문(expression)
		a + b 
 	(2) 문장(statement)
		;
	(3) 용도
		1) count looping
			- N-Loop
		2) array access
			- iterate array
	(4) 
		ANSI-C(america standard)
			c-version	-> c89(c90)(original), c99, c11, c14 (gcc --help)
		func()
		{
		@head - data
			int i;
			int j=123;
		---------------------------
		@body - alogorithm
			i++;
			j=i-3; ...
		

		@ data 선언/정의(x)

	(5) 예제
	
	for(int i=0, j=0; i<3; i++, j++)	// 가능은 함. 추천은 x
	{
	}

3. do~while(조건에 상관없이 한번은 실행하고 더 할지 말지를)
4. 구구단 출력

#include <stdio.h>

int main(void)
{
	int a;
	int b;	
	
	for(a=1; a<10; a++)
	{
		for(b=1; b<10; b++)
		{
			printf("%d * %d = %d\n", a, b, a*b);
		}		
	}
}
5. break(자기가 속한 반복문의 block을 빠져나온다)
6. continue
7. 무한 반복문

======================================================
// 7장. 함수 //

1. 함수 - 선언(type, name, variable), 정의(내용)
2. variable scope
 (1) scope
	1) 전역(global scope variable)
		- outside of {} : 어떤 블록 안에도 속해있지 않아야함.
	2) 지역(local scope variable)
		- inside of {}
	3) 함수(function scope variable) -> 요즘은 잘 언급 안됨. 지역변수랑 성격이 비슷.
		- function(...)
3. parsing
4. void
5. recursive function 재귀함수
 (1) define
	- call itself
 (2) pros
	- 기가막힌 알고리즘
 (3) cons
	- 위험(stack overflow)
	- stack은 큰 메모리가 아니기에 조심해서. 메모리를 크게 쓰지 않는 임베디드 특성상 좀 더 신경써야함.
 (4) 재귀호출 잘짜여진거 소스 찾아보기.
 (5) 예제
 // ! (factorial)
#include <stdio.h>

int r_factorial(int n)
{	
	if(n==0)
	{
		return 1;
	}
	return n * r_factorial(n-1);
}

int n_factorial(int n)
{
	int r=1;
	while(n)
	{
		r=r*(n--);
	}
	return r;
}

int main(void)
{
	int n;
	int r;
	printf("%s:", "input number");
	scanf("%d", &n);
	
	r=r_factorial(n);
	printf("n! is %d\n", r);
	
	r=n_factorial(n);
	printf("n! is %d\n", r);
	
	return 0;
}

======================================================
// 8장. 배열 // (******************)

1. 배열

정의 : 메모리상에 동일한 type의 data가 연속적으로 놓여져 있는 상태.

int ga[5]={10,1,2};	// 뒤에 2개는 0

int gi=1;	// .DATA section
int gni;	// .BSS-->CRT-->0으로 initialize

int ga[5]; // 초기화 안한 경우

{
	1차원
	int a[5];
	int a[5]={0,  };		// 초기부터 0으로 초기화 하는 방법 중 한가지	
	int b[3]={int, int, int};	// stack structure 그려보기
	int c[5]={10,1,2        };	// 뒤에 0
	
	

	printf(a[0]);	// gabage
	printf(ga[0]);	// 0
	
	2차원
	int aa[3][4];		// y x
	
	3차원
	int aaa[2][3][4];	// z y x
	
	
	
#include <stdio.h>

int gi-123;
int gni;		// 0 나옴 // c commitee

int main(void)
{
	int li=1;
	int lni;		// 쓰레기값. 스택 밖
	
2. Memory

 (1) Non Volatile Memory
	- 값 유지. OFF->On (1->1)
	- ROM ( program code <- download해서 집어넣음)
		.Text( .Rdata = .const )
		.Data
		.BSS

 (2) Volatile Memory
	- 값 유지x. OFF->On (1->0)

3. BSS

int gi=123;	// .DATA	초기화를 한 전역변수	// copied to RAM by CRT
int gni1;	// .BSS		초기화를 하지 않은 전역변수	// zero-copy init by CRT

int gx=0;	// .BSS		

int gy[1000]=0;	// 이게 만약 .DATA에 잡힌다고 한다면??
{
	int li=11;	// .STACK
	printf("%d, gi);	// 123
	printf("%d, gni1);	// 0
}

a.c -> a.o -> a.exe(@HDD) ---> a.exe(@RAM)
	안에 gi가 123이라는게 있으니 printf가 나옴
	gni1이 0이라는게 있으니 0출력.
	
	
	ROM은 readonly memory라 값을 바꿀 수가 없음. 그래서 RAM에 복사를 해서 사용.
	
	'CRT'(main 함수 실행하기 전에)가 .DATA에 있는 애들을 ROM에서 RAM으로 그냥 copy.
	.BSS에 있는 애들은 RAM으로 0값으로 copy. 이게 'Zero Initialize'
	
	"ROM 구조 RAM 구조 그려서 도식화 해보기."
	
	※ CRT - SP 잡아줌, 초기화 된 전역변수(.DATA)와 초기화 되지 않은 전역변수(.BSS) 0값으로 채워주는 ZI작업

4. 배열과 반복문 궁합 좋음
5. sizeof	array
{
	  (type id=iv;)
	i) int i=123;
	
	ii) int a[3]={ int, int, int };
	   (type = int)
	   (id = a)
	
	ex1)
	int a[3];
	(1) 표준식(표준식으로 따져야 배열이 들어간 식을 제대로 따질 수 있다.)
		type id = iv;
		int[3] a;
		sizeof(a)

	(2) 표현식
		문법적으로 올바른식;
		int a[3];
	
int a[5];
sizeof(a[0])	=== 	4
sizeof(a)		===	4*5 = 20

6. 괄호
 (1) {} - braces
 (2) () - parenthesis
 (3) []	- bracket
 (4) <>	- square bracket

7. 포인터 배열 등가식(Pointer Array Equation)

	A[N] == *(A+N)
	
	ex1)
		a[3]==*(a+3)
	
	ex2)
	{
		int a[5]={10,1,2,3,4};
	1)	printf("%d", &a[0]);			//	1000
			-> 배열 a의 첫번째 index (0) 요소의 주소
			
	2)	printf("%d", a);			//	1000
			-> 배열 a의 첫번째 index (0) 요소의 주소
	3)	printf("%d", &a);			//	1000(주소)
			-> 배열 a의 시작주소 ? 추후 포인터.
			
	1번 2번 같다는 증명(암기)
	a[0]==*(a+0)==*(a)==*a
	a[0]==*a
	&a[0]==&*a(&와 * 붙으면 상쇄)==a -> a의 첫번재 엘리먼트의 주소[0]
	
		=> 1번 2번이 같다. 

======================================================
// 9장.  포인터 //

1. 	int i = 123;		// i는 int 형 변수
	
	int a[4]={10, 1, 2, 3};			// a는 1차원 배열의 (0th element address)
	
	int aa[3][4]		// aa는 2차원 배열
	
	int aaa[2][3][4]	// aaa는 3차원 배열
	
	int ***ppp;			// 3차원 포인터
	
	int **pp;			// 2차원 포인터
	
	int *p;				// 1차원 포인터 (변수)
	
	int i;				// 0차원 포인터
	
	i = 123;
	
	p = &i;				// 우에다가 1000 (주소)
	*p=456;
	printf("%d", i) ; // 456
	
	&i의 정체는 1차원 포인터의 상수
	
	(int*)=(int* (const))		// 왼쪽 int*면 오른쪽도 int*
	
	i=j;				// (int변수)=(int변수)
	i=3;				// (int변수)=(int상수)
	
	&연산자는 id의 차원 하나 +
	
	pointer 변수
	array 상수
	
	& vs *
	간접참조연산자

2. pointer의 성향

	1. 좌향
		address<----
		
		i = 456;
		printf("%d", &i);	(1차원 좌향)
		
		
		
	2. 우향
		----> Data
		
		i = 456;
		printf("%d", i);	(0차원 우향)
	
	
	p = &i;				// 우에다가 1000 (가정한 주소 값)

3. identifier의 정체성 정의	-< {포인터/배열}
	
	int * p ; 	// p?	--> 1차/포인터/변수
	int a[3];	// a?	--> 1차/배열/상수
	
	int **xxxx[2][3];	--> xxxx? 배열
	4 --> 배열
	3 --> 배열
	2 --> 포인터 (변수)
	1 --> 포인터 (변수)
	0 --> 포인터 (0차원 변수)
	
	xxxx[0] == *xxxx				3
	xxxx[0][0] == **xxxx			2
	xxxx[0][0][0] == ***xxxx		1
	xxxx[0][0][0][0] == ****xxxx	0
	
	*xxxx[0][0]	== 
@head
---------------------------
@body

	

	p =			// o
	a =			// x
	
	indirect reference
	
	*p;		indirect reference 간접참조연산자
	a[2];	indexing operation 배열참조연산자
	
	[]	1순위
	*	2순위













































