// 2024년 7월 17일 //
=====================================================
Review

	
	*	-> identifier의 정체성을 pointer (pointer 변수)
	[]	-> identifier의 정체성을 array(pointer 상수)

@head
-----------
@body

	&
	*
	[]

=====================================================
// 9. 포인터 //
1. 주소연산자 &
- 차원 왼쪽으로 하나 올림. 메모리의 주소값.

cf)	Computer Architecture에 관한 내용.

{
	register int i=123;
			// stack이 아닌 register에 잡도록해줌
			// register ( embedded에서 사용, FPGA보드 했을 때 봄 )
			// CPU, cache, register(자주 사용하는 것을 옆에둬서 처리 속도가 빠르도록. 한정적, 남용은 안됨) 관계
	printf("%d", &i);	// 안됨. 주소는 address bus를 통해 접근을 할 수 있는것. register나 alu 같은 것들은 cpu내에 있기 때문에 주소 x

2. 포인터와 간접 참조 연산자 *(head pointer변수 / body 간참연)
- 책 예제 9-2 살펴보기. head/body

3. const pointer

{
	const int ci = 123;	// const는 값을 상수 형태로 꼭 줘야함. 나중에 못바꾸니깐
	
※ const의 목적어가 안된다고 생각 ※
1)	const int *p=100;	// 주소
	const	*p=100;	// type 빼고 뒤 목적어 나온게 안된다고 생각.
	p=0;	// o
	*p=0;	// x

2)	int const *p=100;
	p=0;	// o
	*p=0;	// x

3)	int *const p=100;
	p=0;	// x
	*p=0;	// o

4)	int const * const p=100;
	p=0;	// x. 뒤 const의 목적어 p
	*p=0;	// x. 앞 const의 목적이 *p

5)	const int *const p=100;
	p=0;	// x
	*p=0;	// x

4. 주소(포인터상수)

=====================================================
// 10. 배열과 포인터 //

1. 포인터 배열 등가식을 통한 변환(& * []) (예제 10-1)

2. pointer to array

ex)

	1)	int i=123;
		int *pi;
		pi=&i;	// o (int*)=(int*)
	
	2)	int a[]={10,1,2};	// 일차원 배열 받는법
			int a[3];	// 표현식
			int[3] a;	// 표준식
			int [] a;	
			int * p;

		int *p;
		p=a;

3. array
ex)
	1)	int a[]={10,1,2,3,4};	// 10=100번지
		printf("%d", a);	// a는 100번지 찍힘

		
		printf("%d", a+1);	// a+1은 104번지(index 하나가 int니 4byte)
		a+1===(int*)+1 (int) ==> int*+int*

	cf)	x32
		sizeof(int)==4B
		sizeof(int*)==4B
		X64
		sizeof(int)==4B
		sizeof(int*)==8B
		
		wordsize	// 컴퓨터가 한번에 처리할 수 있는 size가 word. register의 폭은 wordsize를 따라감.

	2)	int aa[][4]={10,1,2,3,4,5,6,7};	//10= 100번지
			={
				{10,1,2,3},		={X}
				{4,5,6,7}		={Y}
			  }
		int aa[2][4]
		int[4] aa[2]	// aa[0]은 {10,1,2,3}, aa[1]은 {4,5,6,7}
		
		printf("%d", aa);

		printf("%d", aa+1==&aa[1])


		printf("%d", aa[1]);;	// 116??

	3) 	int a[]	=	{};
		p?
		//1차원-1차원
		int []a;
		int	*p;
	
		//2차원
		int aa[2][3];
		int[3]	aa[2];
		int[3]	[]	aa;
		int[3]	*	pp;	// 표준식
		int	*pp[3];		// 표현식. pp[3] : 배열 (int* int* int*)
		int	(*pp)[3];		// 괄호를 쳐주면 ()와 []싸우지 않음.
		pp=aa;			// o
	
cf) 배열의 포인터 vs 포인터의 배열 (예제 많이 풀어보기)
()와 []는 일진이기때문에 먼저 받는다. 근데  (type cast) 는 단항연산자이기에 ()를 한번 더 써줘야함.

=====================================================
// 11. 문자 //

1. 아스키
A : 65
a : 97	(+32==2^5==(1<<5bit))

=====================================================
// 12. 문자열 //

1. 문자열 상수는 주소 (""가 리턴하는 값 char*)

2. const
	1)
	void func(char *str)	// const char *str처럼 const(상수)가 되게끔 사용하면 l_value 넘어오지 못함.
	{
		str[4]='\0';	
	}

	int main()
	{
		func("hello");
		printf("%s", );
	}

3. stdio
		FDT	pc		embedded

stdin		0	keyboard		UART(serial)	by scanf
stdout		1	monitor		UART(serial)	by printf
stderror		2	monitor		UART(serial)	by perror

4. str시리즈



